from __future__ import annotations

import logging
import re
import uuid
from dataclasses import dataclass
from datetime import UTC, datetime
from typing import Iterable

logger = logging.getLogger(__name__)

_SENTENCE_BOUNDARY = re.compile(r"(?<=[.!?])\s+(?=[A-Z0-9])")
_MULTISPACE = re.compile(r"\s{2,}")


@dataclass(slots=True)
class SpeechSegment:
    """Single utterance slice optimised for natural speech synthesis."""

    text: str
    estimated_duration: float
    pause_after: float

    def to_payload(self) -> dict[str, float | str]:
        """Return a serialisable representation of the segment."""

        return {
            "text": self.text,
            "estimated_duration": self.estimated_duration,
            "pause_after": self.pause_after,
        }


@dataclass(slots=True)
class SpeechTurn:
    """Conversation-aware speech turn generated by :class:`Bouche`."""

    turn_id: str
    text: str
    created_at: datetime
    segments: list[SpeechSegment]
    average_words_per_second: float
    tempo: float

    def to_payload(self) -> dict[str, object]:
        """Return a serialisable payload for API responses."""

        return {
            "turn_id": self.turn_id,
            "text": self.text,
            "created_at": self.created_at.isoformat(),
            "segments": [segment.to_payload() for segment in self.segments],
            "average_words_per_second": self.average_words_per_second,
            "tempo": self.tempo,
        }


class SpeechTurnManager:
    """Plan conversationally-aware speech segments.

    The manager keeps a rolling estimate of the agent's tempo in order to adapt
    pauses and per-segment pacing so that responses sound natural when spoken by
    a TTS engine or read aloud by a human operator.
    """

    def __init__(
        self,
        *,
        target_words_per_minute: int = 165,
        min_pause: float = 0.18,
        max_pause: float = 1.35,
    ) -> None:
        self._target_words_per_second = target_words_per_minute / 60
        self._min_pause = min_pause
        self._max_pause = max_pause
        self._rolling_tempo: float | None = None
        self._average_pause: float | None = None
        self._turn_count = 0

    def plan_turn(
        self, text: str, *, last_turn: SpeechTurn | None = None
    ) -> SpeechTurn:
        """Generate a :class:`SpeechTurn` from ``text``.

        Parameters
        ----------
        text:
            The response text that should be delivered to the user.
        last_turn:
            The previously delivered speech turn. When provided the pacing of the
            current turn will be adapted to keep the dialogue flowing naturally.
        """

        cleaned_segments = list(self._split_into_segments(text))
        if not cleaned_segments:
            cleaned_segments = ["..."]

        total_words = sum(self._count_words(segment) for segment in cleaned_segments)
        total_words = max(total_words, 1)

        segments: list[SpeechSegment] = []
        cumulative_duration = 0.0

        for index, segment_text in enumerate(cleaned_segments):
            words = max(self._count_words(segment_text), 1)
            base_duration = max(words / self._target_words_per_second, 0.35)
            tempo_modifier = self._tempo_modifier(last_turn)
            duration = base_duration * tempo_modifier
            cumulative_duration += duration

            pause_after = self._calculate_pause(
                index,
                len(cleaned_segments),
                duration,
                last_turn=last_turn,
            )

            segments.append(
                SpeechSegment(
                    text=segment_text,
                    estimated_duration=round(duration, 3),
                    pause_after=round(pause_after, 3),
                )
            )

        average_words_per_second = total_words / cumulative_duration
        tempo = min(
            1.35,
            max(0.65, average_words_per_second / self._target_words_per_second),
        )

        self._register_turn_stats(segments, tempo)

        return SpeechTurn(
            turn_id=str(uuid.uuid4()),
            text=text,
            created_at=datetime.now(UTC),
            segments=segments,
            average_words_per_second=round(average_words_per_second, 3),
            tempo=round(tempo, 3),
        )

    def conversation_profile(self) -> dict[str, float | int]:
        """Return aggregate pacing metrics for the current conversation."""

        return {
            "turn_count": self._turn_count,
            "tempo": self._rolling_tempo if self._rolling_tempo is not None else 1.0,
            "average_pause": (
                self._average_pause
                if self._average_pause is not None
                else self._min_pause
            ),
        }

    def _split_into_segments(self, text: str) -> Iterable[str]:
        stripped = text.strip()
        if not stripped:
            return []

        normalised = _MULTISPACE.sub(" ", stripped)
        parts = _SENTENCE_BOUNDARY.split(normalised)
        return [part.strip() for part in parts if part.strip()]

    @staticmethod
    def _count_words(text: str) -> int:
        return len([token for token in text.split(" ") if token])

    def _tempo_modifier(self, last_turn: SpeechTurn | None) -> float:
        if last_turn is None:
            return 1.0
        baseline = self._rolling_tempo if self._rolling_tempo is not None else 1.0
        recent_tempo = last_turn.tempo
        return max(0.85, min(1.15, (baseline + recent_tempo) / 2))

    def _calculate_pause(
        self,
        index: int,
        segments_count: int,
        duration: float,
        *,
        last_turn: SpeechTurn | None,
    ) -> float:
        base = max(self._min_pause, min(duration * 0.35, self._max_pause))
        if index == segments_count - 1:
            base = min(self._max_pause, base + 0.25)
        elif index == 0 and last_turn is not None:
            base = max(self._min_pause, base * 0.75)
        return base

    def _register_turn_stats(self, segments: list[SpeechSegment], tempo: float) -> None:
        pauses = [segment.pause_after for segment in segments]
        average_pause = sum(pauses) / len(pauses)

        if self._rolling_tempo is None:
            self._rolling_tempo = tempo
        else:
            self._rolling_tempo = (self._rolling_tempo * 0.4) + (tempo * 0.6)

        if self._average_pause is None:
            self._average_pause = average_pause
        else:
            self._average_pause = (
                self._average_pause * self._turn_count + average_pause
            ) / (self._turn_count + 1)

        self._turn_count += 1


class Bouche:
    """Output interface for delivering conversationally-optimised responses."""

    def __init__(self, manager: SpeechTurnManager | None = None) -> None:
        self._manager = manager or SpeechTurnManager()
        self._last_turn: SpeechTurn | None = None

    async def speak(self, text: str) -> SpeechTurn:
        """Plan a speech turn from ``text`` and return detailed metadata."""

        turn = self._manager.plan_turn(text, last_turn=self._last_turn)
        self._last_turn = turn

        logger.info(
            "bouche.speech_turn",
            extra={
                "turn_id": turn.turn_id,
                "segments": len(turn.segments),
                "tempo": turn.tempo,
                "average_words_per_second": turn.average_words_per_second,
            },
        )
        return turn

    def conversation_profile(self) -> dict[str, float]:
        """Expose aggregate pacing metrics for downstream diagnostics."""

        return self._manager.conversation_profile()
