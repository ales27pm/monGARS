"""Persistence utilities for operator approval workflows.

This module provides a lightweight registry that records rollout approval
requests and tracks their disposition.  The intent is to give orchestration
code a durable handshake with human operators (or automated policies) before
deploying experimental artefacts generated by reinforcement-learning loops.

The registry stores records on disk as JSON so that approvals survive process
restarts and can be inspected or amended by external tooling.  The format is
stable and intentionally simple::

    {
        "requests": [
            {
                "id": "...",
                "fingerprint": "...",
                "source": "reinforcement.reasoning",
                "status": "pending",
                "payload": {...},
                "created_at": "2025-10-05T12:00:00+00:00",
                "approved_by": null,
                "approved_at": null,
                "notes": null
            }
        ]
    }

The helper exposes a `require_approval` method that callers can use to gate a
deployment.  When an automated policy is supplied the request is
auto-approved; otherwise the request is persisted in ``pending`` status so an
operator can review it from the Django console or offline tooling.
"""

from __future__ import annotations

import json
import threading
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Callable, Iterable, Mapping
from uuid import uuid4

ApprovalPolicy = Callable[[Mapping[str, Any]], bool]


def _utcnow_isoformat() -> str:
    return datetime.now(timezone.utc).isoformat()


def _normalise_payload(payload: Mapping[str, Any]) -> dict[str, Any]:
    """Return a JSON-serialisable copy of ``payload``.

    The function walks nested mappings to ensure keys are strings so the
    payload can be dumped deterministically when computing fingerprints.
    """

    def _convert(value: Any) -> Any:
        if isinstance(value, Mapping):
            return {str(key): _convert(sub_value) for key, sub_value in value.items()}
        if isinstance(value, (list, tuple, set)):
            return [_convert(item) for item in value]
        return value

    return _convert(payload)  # type: ignore[return-value]


def _fingerprint(source: str, payload: Mapping[str, Any]) -> str:
    normalised = _normalise_payload(payload)
    serialised = json.dumps(normalised, sort_keys=True, separators=(",", ":"))
    # The UUID namespace is sufficient for collision resistance while keeping
    # the output stable across runs for identical payloads.
    from uuid import uuid5, NAMESPACE_URL

    return uuid5(NAMESPACE_URL, f"{source}:{serialised}").hex


@dataclass(slots=True)
class ApprovalRequest:
    """Represent a single approval decision for a rollout artefact."""

    request_id: str
    source: str
    payload: dict[str, Any]
    fingerprint: str
    status: str = "pending"
    created_at: str = field(default_factory=_utcnow_isoformat)
    approved_by: str | None = None
    approved_at: str | None = None
    notes: str | None = None

    def to_dict(self) -> dict[str, Any]:
        return {
            "id": self.request_id,
            "source": self.source,
            "payload": self.payload,
            "fingerprint": self.fingerprint,
            "status": self.status,
            "created_at": self.created_at,
            "approved_by": self.approved_by,
            "approved_at": self.approved_at,
            "notes": self.notes,
        }

    @classmethod
    def from_dict(cls, data: Mapping[str, Any]) -> "ApprovalRequest":
        return cls(
            request_id=str(data.get("id") or data.get("request_id") or uuid4().hex),
            source=str(data.get("source") or "unknown"),
            payload=_normalise_payload(data.get("payload", {})),
            fingerprint=str(data.get("fingerprint") or uuid4().hex),
            status=str(data.get("status") or "pending"),
            created_at=str(data.get("created_at") or _utcnow_isoformat()),
            approved_by=(
                str(data.get("approved_by")) if data.get("approved_by") else None
            ),
            approved_at=(
                str(data.get("approved_at")) if data.get("approved_at") else None
            ),
            notes=str(data.get("notes")) if data.get("notes") else None,
        )

    @property
    def is_pending(self) -> bool:
        return self.status.lower() == "pending"

    @property
    def is_approved(self) -> bool:
        return self.status.lower() == "approved"


class OperatorApprovalRegistry:
    """Persist and evaluate rollout approval requests."""

    def __init__(self, storage_path: str | Path) -> None:
        self._path = Path(storage_path)
        self._path.parent.mkdir(parents=True, exist_ok=True)
        self._lock = threading.Lock()
        self._requests: dict[str, ApprovalRequest] = {}
        self._load()

    def _load(self) -> None:
        if not self._path.exists():
            return
        try:
            raw = json.loads(self._path.read_text(encoding="utf-8"))
        except Exception:
            return
        for item in raw.get("requests", []):
            try:
                request = ApprovalRequest.from_dict(item)
            except Exception:
                continue
            self._requests[request.request_id] = request

    def _persist(self) -> None:
        payload = {"requests": [req.to_dict() for req in self._requests.values()]}
        self._path.write_text(
            json.dumps(payload, indent=2, sort_keys=True), encoding="utf-8"
        )

    def _find_by_fingerprint(self, fingerprint: str) -> ApprovalRequest | None:
        for request in self._requests.values():
            if request.fingerprint == fingerprint:
                return request
        return None

    def submit(
        self,
        *,
        source: str,
        payload: Mapping[str, Any],
        policy: ApprovalPolicy | None = None,
    ) -> ApprovalRequest:
        normalised = _normalise_payload(payload)
        fingerprint = _fingerprint(source, normalised)
        with self._lock:
            existing = self._find_by_fingerprint(fingerprint)
            if existing is not None:
                if (
                    policy is not None
                    and existing.is_pending
                    and policy(existing.payload)
                ):
                    self._mark_approved(existing, approver="auto-policy")
                return existing

            request = ApprovalRequest(
                request_id=uuid4().hex,
                source=source,
                payload=normalised,
                fingerprint=fingerprint,
            )
            if policy is not None and policy(normalised):
                self._mark_approved(request, approver="auto-policy")
            self._requests[request.request_id] = request
            self._persist()
            return request

    def require_approval(
        self,
        *,
        source: str,
        payload: Mapping[str, Any],
        policy: ApprovalPolicy | None = None,
    ) -> bool:
        request = self.submit(source=source, payload=payload, policy=policy)
        return request.is_approved

    def approve(
        self,
        request_id: str,
        *,
        operator: str,
        notes: str | None = None,
    ) -> ApprovalRequest:
        with self._lock:
            request = self._requests.get(request_id)
            if request is None:
                raise KeyError(f"Approval request {request_id!r} not found")
            self._mark_approved(request, approver=operator, notes=notes)
            self._persist()
            return request

    def _mark_approved(
        self,
        request: ApprovalRequest,
        *,
        approver: str,
        notes: str | None = None,
    ) -> None:
        request.status = "approved"
        request.approved_by = approver
        request.approved_at = _utcnow_isoformat()
        request.notes = notes

    def pending(self, *, source: str | None = None) -> Iterable[ApprovalRequest]:
        for request in self._requests.values():
            if not request.is_pending:
                continue
            if source is not None and request.source != source:
                continue
            yield request


__all__ = [
    "ApprovalRequest",
    "OperatorApprovalRegistry",
    "ApprovalPolicy",
]
