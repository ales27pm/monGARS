"""Persistence utilities for operator approval workflows.

This module provides a lightweight registry that records rollout approval
requests and tracks their disposition.  The intent is to give orchestration
code a durable handshake with human operators (or automated policies) before
deploying experimental artefacts generated by reinforcement-learning loops.

The registry stores records on disk as JSON so that approvals survive process
restarts and can be inspected or amended by external tooling.  The format is
stable and intentionally simple::

    {
        "requests": [
            {
                "id": "...",
                "fingerprint": "...",
                "source": "reinforcement.reasoning",
                "status": "pending",
                "payload": {...},
                "created_at": "2025-10-05T12:00:00+00:00",
                "approved_by": null,
                "approved_at": null,
                "notes": null
            }
        ]
    }

The helper exposes a `require_approval` method that callers can use to gate a
deployment.  When an automated policy is supplied the request is
auto-approved; otherwise the request is persisted in ``pending`` status so an
operator can review it from the Django console or offline tooling.
"""

from __future__ import annotations

import hashlib
import hmac
import json
import logging
import threading
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING, Any, Callable, Iterable, Mapping, Sequence
from uuid import uuid4

from monGARS.config import get_settings

if TYPE_CHECKING:
    from .pii_detection import PIIEntity

logger = logging.getLogger(__name__)

ApprovalPolicy = Callable[[Mapping[str, Any]], bool]


def _utcnow_isoformat() -> str:
    return datetime.now(timezone.utc).isoformat()


def _normalise_payload(payload: Mapping[str, Any]) -> dict[str, Any]:
    """Return a JSON-serialisable copy of ``payload``.

    The function walks nested mappings to ensure keys are strings so the
    payload can be dumped deterministically when computing fingerprints.
    """

    def _convert(value: Any) -> Any:
        if isinstance(value, Mapping):
            return {str(key): _convert(sub_value) for key, sub_value in value.items()}
        if isinstance(value, (list, tuple, set)):
            return [_convert(item) for item in value]
        return value

    return _convert(payload)  # type: ignore[return-value]


def _fingerprint(source: str, payload: Mapping[str, Any]) -> str:
    normalised = _normalise_payload(payload)
    serialised = json.dumps(normalised, sort_keys=True, separators=(",", ":"))
    # The UUID namespace is sufficient for collision resistance while keeping
    # the output stable across runs for identical payloads.
    from uuid import NAMESPACE_URL, uuid5

    return uuid5(NAMESPACE_URL, f"{source}:{serialised}").hex


@dataclass(slots=True)
class ApprovalRequest:
    """Represent a single approval decision for a rollout artefact."""

    request_id: str
    source: str
    payload: dict[str, Any]
    fingerprint: str
    status: str = "pending"
    created_at: str = field(default_factory=_utcnow_isoformat)
    approved_by: str | None = None
    approved_at: str | None = None
    notes: str | None = None

    def to_dict(self) -> dict[str, Any]:
        return {
            "id": self.request_id,
            "source": self.source,
            "payload": self.payload,
            "fingerprint": self.fingerprint,
            "status": self.status,
            "created_at": self.created_at,
            "approved_by": self.approved_by,
            "approved_at": self.approved_at,
            "notes": self.notes,
        }

    @classmethod
    def from_dict(cls, data: Mapping[str, Any]) -> "ApprovalRequest":
        return cls(
            request_id=str(data.get("id") or data.get("request_id") or uuid4().hex),
            source=str(data.get("source") or "unknown"),
            payload=_normalise_payload(data.get("payload", {})),
            fingerprint=str(data.get("fingerprint") or uuid4().hex),
            status=str(data.get("status") or "pending"),
            created_at=str(data.get("created_at") or _utcnow_isoformat()),
            approved_by=(
                str(data.get("approved_by")) if data.get("approved_by") else None
            ),
            approved_at=(
                str(data.get("approved_at")) if data.get("approved_at") else None
            ),
            notes=str(data.get("notes")) if data.get("notes") else None,
        )

    @property
    def is_pending(self) -> bool:
        return self.status.lower() == "pending"

    @property
    def is_approved(self) -> bool:
        return self.status.lower() == "approved"


class OperatorApprovalRegistry:
    """Persist and evaluate rollout approval requests."""

    def __init__(self, storage_path: str | Path) -> None:
        self._path = Path(storage_path)
        self._path.parent.mkdir(parents=True, exist_ok=True)
        self._lock = threading.Lock()
        self._requests: dict[str, ApprovalRequest] = {}
        self._load()

    def _load(self) -> None:
        if not self._path.exists():
            return
        try:
            raw = json.loads(self._path.read_text(encoding="utf-8"))
        except Exception:
            return
        for item in raw.get("requests", []):
            try:
                request = ApprovalRequest.from_dict(item)
            except Exception:
                continue
            self._requests[request.request_id] = request

    def _persist(self) -> None:
        payload = {"requests": [req.to_dict() for req in self._requests.values()]}
        self._path.write_text(
            json.dumps(payload, indent=2, sort_keys=True), encoding="utf-8"
        )

    def _find_by_fingerprint(self, fingerprint: str) -> ApprovalRequest | None:
        for request in self._requests.values():
            if request.fingerprint == fingerprint:
                return request
        return None

    def submit(
        self,
        *,
        source: str,
        payload: Mapping[str, Any],
        policy: ApprovalPolicy | None = None,
    ) -> ApprovalRequest:
        normalised = _normalise_payload(payload)
        fingerprint = _fingerprint(source, normalised)
        with self._lock:
            existing = self._find_by_fingerprint(fingerprint)
            if existing is not None:
                if (
                    policy is not None
                    and existing.is_pending
                    and policy(existing.payload)
                ):
                    self._mark_approved(existing, approver="auto-policy")
                return existing

            request = ApprovalRequest(
                request_id=uuid4().hex,
                source=source,
                payload=normalised,
                fingerprint=fingerprint,
            )
            if policy is not None and policy(normalised):
                self._mark_approved(request, approver="auto-policy")
            self._requests[request.request_id] = request
            self._persist()
            return request

    def require_approval(
        self,
        *,
        source: str,
        payload: Mapping[str, Any],
        policy: ApprovalPolicy | None = None,
    ) -> bool:
        request = self.submit(source=source, payload=payload, policy=policy)
        return request.is_approved

    def approve(
        self,
        request_id: str,
        *,
        operator: str,
        notes: str | None = None,
    ) -> ApprovalRequest:
        with self._lock:
            request = self._requests.get(request_id)
            if request is None:
                raise KeyError(f"Approval request {request_id!r} not found")
            self._mark_approved(request, approver=operator, notes=notes)
            self._persist()
            return request

    def _mark_approved(
        self,
        request: ApprovalRequest,
        *,
        approver: str,
        notes: str | None = None,
    ) -> None:
        request.status = "approved"
        request.approved_by = approver
        request.approved_at = _utcnow_isoformat()
        request.notes = notes

    def pending(self, *, source: str | None = None) -> Iterable[ApprovalRequest]:
        for request in self._requests.values():
            if not request.is_pending:
                continue
            if source is not None and request.source != source:
                continue
            yield request


_AUDIT_SOURCE = "security.guardrail"
_DEFAULT_APPROVALS_PATH = Path("models/encoders/operator_approvals.json")
_GLOBAL_REGISTRY: OperatorApprovalRegistry | None = None
_GLOBAL_REGISTRY_LOCK = threading.Lock()


def _default_registry() -> OperatorApprovalRegistry:
    global _GLOBAL_REGISTRY
    with _GLOBAL_REGISTRY_LOCK:
        if _GLOBAL_REGISTRY is None:
            _GLOBAL_REGISTRY = OperatorApprovalRegistry(_DEFAULT_APPROVALS_PATH)
        return _GLOBAL_REGISTRY


def log_blocked_attempt(
    *,
    user_id: str,
    prompt_hash: str,
    pii_entities: Sequence["PIIEntity"],
    required_action: str,
    context: Mapping[str, Any],
    registry: OperatorApprovalRegistry | None = None,
) -> str:
    """Persist details about a blocked security guardrail decision."""

    if not user_id:
        user_id = "anonymous"
    if not prompt_hash:
        raise ValueError("prompt_hash must not be empty")
    if not required_action:
        raise ValueError("required_action must not be empty")

    serialized_entities = [
        {
            "type": entity.type,
            "value_preview": entity.value[:64],
            "start": entity.start,
            "end": entity.end,
        }
        for entity in pii_entities
    ]

    payload = {
        "user_id": user_id,
        "prompt_hash": prompt_hash,
        "required_action": required_action,
        "pii_entities": serialized_entities,
        "context_snapshot": _normalise_payload(context),
        "blocked_at": _utcnow_isoformat(),
    }

    approval_registry = registry or _default_registry()
    request = approval_registry.submit(source=_AUDIT_SOURCE, payload=payload)

    logger.info(
        "operator_approvals.blocked_request_logged",
        extra={
            "source": _AUDIT_SOURCE,
            "request_id": request.request_id,
            "user_id": user_id,
            "prompt_hash": prompt_hash,
            "blocked_entity_types": sorted({e["type"] for e in serialized_entities}),
        },
    )

    return request.request_id


def generate_approval_token(user_id: str, token_ref: str) -> str:
    """Return a deterministic approval token tied to ``user_id`` and reference."""

    if not token_ref:
        raise ValueError("token_ref must not be empty")
    user_identifier = user_id or "anonymous"
    secret = get_settings().SECRET_KEY or "monGARS-approval-secret"
    payload = f"{user_identifier}:{token_ref}".encode("utf-8")
    digest = hmac.new(secret.encode("utf-8"), payload, hashlib.sha256).hexdigest()
    return digest[:32]


__all__ = [
    "ApprovalRequest",
    "OperatorApprovalRegistry",
    "ApprovalPolicy",
    "log_blocked_attempt",
    "generate_approval_token",
]
