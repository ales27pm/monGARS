"""Helpers to load ChatAndEmbed wrapper bundles generated by training scripts."""

from __future__ import annotations

import hashlib
import importlib.util
import json
import logging
import sys
from dataclasses import dataclass
from pathlib import Path
from types import ModuleType
from typing import Any

from .artifacts import WrapperConfig

logger = logging.getLogger(__name__)


class WrapperBundleError(RuntimeError):
    """Raised when a wrapper bundle is incomplete or invalid."""


@dataclass(frozen=True)
class WrapperBundle:
    """Loaded wrapper metadata and module reference."""

    config: WrapperConfig
    module: ModuleType
    module_path: Path
    chat_class: type

    def create_instance(self) -> Any:
        """Instantiate the ``ChatAndEmbed`` class defined in the bundle."""

        try:
            return self.chat_class()
        except Exception as exc:  # pragma: no cover - defensive guard
            raise WrapperBundleError(
                f"Failed to instantiate ChatAndEmbed: {exc}"
            ) from exc


def _resolve_directory(root: Path | str) -> Path:
    path = Path(root)
    if path.is_file():
        path = path.parent
    return path.resolve()


def _load_module(module_path: Path) -> ModuleType:
    module_id = (
        f"project_wrapper_{hashlib.sha1(str(module_path).encode()).hexdigest()[:8]}"
    )
    spec = importlib.util.spec_from_file_location(module_id, module_path)
    if spec is None or spec.loader is None:
        raise WrapperBundleError(f"Unable to load wrapper module from {module_path}")
    module = importlib.util.module_from_spec(spec)
    sys.modules[module_id] = module
    spec.loader.exec_module(module)
    return module


def _coerce_bool(value: Any, default: bool) -> bool:
    if value is None:
        return default
    if isinstance(value, bool):
        return value
    if isinstance(value, str):
        return value.strip().lower() not in {"false", "0", "no", "off"}
    return bool(value)


def _load_config(config_path: Path) -> WrapperConfig:
    try:
        data = json.loads(config_path.read_text())
    except FileNotFoundError as exc:
        raise WrapperBundleError(f"Wrapper config missing at {config_path}") from exc
    except json.JSONDecodeError as exc:  # pragma: no cover - defensive
        raise WrapperBundleError(f"Invalid wrapper config JSON: {exc}") from exc

    try:
        base_model_id = str(data["base_model_id"])
        lora_dir = Path(data["lora_dir"])
        max_seq_len = int(data["max_seq_len"])
        vram_budget_raw = data.get("vram_budget_mb", 4096)
        vram_budget = int(vram_budget_raw)
        if vram_budget <= 0:
            raise ValueError
        offload_dir = Path(data["offload_dir"])
    except KeyError as exc:
        raise WrapperBundleError(f"Wrapper config missing key: {exc.args[0]}") from exc
    except (TypeError, ValueError) as exc:
        raise WrapperBundleError(
            "Wrapper config contains invalid numeric values"
        ) from exc

    if not lora_dir.is_absolute():
        lora_dir = (config_path.parent / lora_dir).resolve()
    if not offload_dir.is_absolute():
        offload_dir = (config_path.parent / offload_dir).resolve()

    quantized = _coerce_bool(data.get("quantized_4bit"), True)

    return WrapperConfig(
        base_model_id=base_model_id,
        lora_dir=lora_dir,
        max_seq_len=max_seq_len,
        vram_budget_mb=vram_budget,
        offload_dir=offload_dir,
        quantized_4bit=quantized,
    )


def load_wrapper_bundle(wrapper_root: Path | str) -> WrapperBundle:
    """Load a ChatAndEmbed wrapper bundle from ``wrapper_root``."""

    wrapper_dir = _resolve_directory(wrapper_root)
    module_path = wrapper_dir / "project_wrapper.py"
    config_path = wrapper_dir / "config.json"

    if not module_path.exists():
        raise WrapperBundleError(f"Wrapper module missing at {module_path}")
    if not config_path.exists():
        raise WrapperBundleError(f"Wrapper config missing at {config_path}")

    config = _load_config(config_path)
    module = _load_module(module_path)
    chat_class = getattr(module, "ChatAndEmbed", None)
    if chat_class is None:
        raise WrapperBundleError("Wrapper module does not define ChatAndEmbed")

    logger.debug(
        "Loaded wrapper bundle",
        extra={
            "module_path": str(module_path),
            "lora_dir": str(config.lora_dir),
        },
    )
    return WrapperBundle(
        config=config,
        module=module,
        module_path=module_path,
        chat_class=chat_class,
    )


__all__ = ["WrapperBundle", "WrapperBundleError", "load_wrapper_bundle"]
